package bot

import (
	"net"
	"sync"
)

// DatacenterDetector detects if an IP belongs to a known cloud provider
type DatacenterDetector struct {
	mu     sync.RWMutex
	cidrs  []*net.IPNet
	loaded bool
}

// NewDatacenterDetector creates a new datacenter IP detector
func NewDatacenterDetector() *DatacenterDetector {
	d := &DatacenterDetector{}
	d.loadCIDRs()
	return d
}

// loadCIDRs loads known datacenter IP ranges
// These are commonly used CIDR ranges for major cloud providers
// Note: For production, these should be fetched from provider APIs
func (d *DatacenterDetector) loadCIDRs() {
	d.mu.Lock()
	defer d.mu.Unlock()

	// Common datacenter IP ranges (subset for efficiency)
	// AWS, GCP, Azure, DigitalOcean, Linode, Vultr, OVH
	ranges := []string{
		// AWS (partial - major ranges)
		"3.0.0.0/8",
		"13.0.0.0/8",
		"15.0.0.0/8",
		"18.0.0.0/8",
		"34.0.0.0/8",
		"35.0.0.0/8",
		"44.0.0.0/8",
		"52.0.0.0/8",
		"54.0.0.0/8",
		"99.0.0.0/8",
		"100.20.0.0/14",
		"107.20.0.0/14",
		"174.129.0.0/16",
		"175.41.128.0/17",
		"176.32.64.0/19",
		"184.72.0.0/15",
		"184.169.128.0/17",
		"185.48.120.0/22",
		"203.83.220.0/22",
		"204.236.128.0/17",
		"204.246.160.0/19",
		"205.251.192.0/18",
		"216.182.224.0/20",

		// Google Cloud (partial)
		"8.34.208.0/20",
		"8.35.192.0/20",
		"23.236.48.0/20",
		"23.251.128.0/19",
		"34.64.0.0/10",
		"35.184.0.0/13",
		"35.192.0.0/11",
		"104.154.0.0/15",
		"104.196.0.0/14",
		"107.167.160.0/19",
		"107.178.192.0/18",
		"108.59.80.0/20",
		"108.170.192.0/18",
		"130.211.0.0/16",
		"142.250.0.0/15",
		"146.148.0.0/17",
		"162.216.148.0/22",
		"162.222.176.0/21",
		"172.217.0.0/16",
		"173.194.0.0/16",
		"173.255.112.0/20",
		"192.158.28.0/22",
		"199.192.112.0/22",
		"199.223.232.0/21",
		"207.223.160.0/20",
		"208.65.152.0/22",
		"208.68.108.0/22",
		"208.81.188.0/22",
		"208.117.224.0/19",
		"209.85.128.0/17",
		"216.58.192.0/19",
		"216.73.80.0/20",
		"216.239.32.0/19",

		// Microsoft Azure (partial)
		"13.64.0.0/11",
		"13.96.0.0/13",
		"13.104.0.0/14",
		"20.0.0.0/8",
		"23.96.0.0/13",
		"40.64.0.0/10",
		"51.104.0.0/14",
		"51.124.0.0/14",
		"52.96.0.0/12",
		"52.112.0.0/14",
		"52.120.0.0/14",
		"52.136.0.0/13",
		"52.145.0.0/16",
		"52.146.0.0/15",
		"52.148.0.0/14",
		"52.152.0.0/13",
		"52.160.0.0/11",
		"52.224.0.0/11",
		"65.52.0.0/14",
		"70.37.0.0/17",
		"70.37.128.0/18",
		"104.40.0.0/13",
		"104.208.0.0/13",
		"131.253.0.0/16",
		"134.170.0.0/16",
		"137.116.0.0/15",
		"137.135.0.0/16",
		"138.91.0.0/16",
		"157.54.0.0/15",
		"157.56.0.0/14",
		"168.61.0.0/16",
		"168.62.0.0/15",
		"191.232.0.0/13",
		"204.79.180.0/24",
		"207.46.0.0/16",
		"209.240.192.0/19",

		// DigitalOcean (partial)
		"45.55.0.0/16",
		"67.205.128.0/17",
		"68.183.0.0/16",
		"104.131.0.0/16",
		"104.236.0.0/16",
		"107.170.0.0/16",
		"128.199.0.0/16",
		"134.209.0.0/16",
		"137.184.0.0/14",
		"138.68.0.0/15",
		"138.197.0.0/16",
		"139.59.0.0/16",
		"142.93.0.0/16",
		"143.110.0.0/15",
		"143.198.0.0/16",
		"146.185.128.0/17",
		"159.65.0.0/16",
		"159.89.0.0/16",
		"161.35.0.0/16",
		"162.243.0.0/16",
		"163.47.8.0/21",
		"164.90.0.0/16",
		"165.22.0.0/16",
		"165.227.0.0/16",
		"167.71.0.0/16",
		"167.99.0.0/16",
		"174.138.0.0/16",
		"178.62.0.0/16",
		"178.128.0.0/16",
		"188.166.0.0/16",
		"192.241.128.0/17",
		"198.199.64.0/18",
		"206.81.0.0/16",
		"206.189.0.0/16",
		"207.154.192.0/18",
		"209.97.128.0/17",

		// Linode (partial)
		"45.33.0.0/17",
		"45.56.64.0/18",
		"45.79.0.0/16",
		"50.116.0.0/17",
		"66.175.208.0/20",
		"69.164.192.0/18",
		"72.14.176.0/20",
		"74.207.224.0/19",
		"96.126.96.0/19",
		"97.107.128.0/17",
		"139.144.0.0/16",
		"139.162.0.0/16",
		"143.42.0.0/16",
		"170.187.128.0/17",
		"172.104.0.0/15",
		"172.232.0.0/14",
		"173.255.192.0/18",
		"178.79.128.0/17",
		"185.3.92.0/22",
		"192.155.80.0/20",
		"194.195.240.0/21",
		"198.58.96.0/19",
		"198.74.48.0/20",
		"213.168.248.0/22",

		// Vultr (partial)
		"45.32.0.0/15",
		"45.63.0.0/17",
		"45.76.0.0/15",
		"45.77.0.0/16",
		"64.156.0.0/18",
		"64.237.32.0/19",
		"66.42.32.0/19",
		"80.240.16.0/20",
		"95.179.128.0/17",
		"104.207.128.0/17",
		"108.61.0.0/16",
		"136.244.64.0/18",
		"140.82.0.0/17",
		"141.164.32.0/19",
		"144.202.0.0/16",
		"149.28.0.0/16",
		"155.138.128.0/17",
		"158.247.192.0/18",
		"167.179.64.0/19",
		"199.247.0.0/16",
		"207.148.0.0/17",
		"208.167.224.0/19",
		"217.69.0.0/18",

		// OVH (partial)
		"5.39.0.0/17",
		"5.135.0.0/16",
		"5.196.0.0/15",
		"37.59.0.0/16",
		"37.187.0.0/16",
		"46.105.0.0/16",
		"51.38.0.0/15",
		"51.68.0.0/14",
		"51.75.0.0/16",
		"51.77.0.0/16",
		"51.79.0.0/16",
		"51.81.0.0/16",
		"51.83.0.0/16",
		"51.89.0.0/16",
		"51.91.0.0/16",
		"54.36.0.0/14",
		"57.128.0.0/11",
		"79.137.0.0/17",
		"87.98.128.0/17",
		"91.121.0.0/16",
		"92.222.0.0/16",
		"94.23.0.0/16",
		"135.125.0.0/16",
		"137.74.0.0/16",
		"139.99.0.0/16",
		"141.94.0.0/16",
		"142.4.192.0/18",
		"144.217.0.0/16",
		"145.239.0.0/16",
		"147.135.0.0/16",
		"149.56.0.0/16",
		"151.80.0.0/16",
		"158.69.0.0/16",
		"162.19.0.0/16",
		"164.132.0.0/16",
		"167.114.0.0/16",
		"176.31.0.0/16",
		"178.32.0.0/16",
		"185.12.32.0/22",
		"188.165.0.0/16",
		"192.95.0.0/16",
		"192.99.0.0/16",
		"193.70.0.0/16",
		"195.154.0.0/16",
		"198.27.64.0/18",
		"198.245.48.0/20",
		"213.186.32.0/19",
		"213.251.128.0/17",

		// Hetzner (partial)
		"5.9.0.0/16",
		"23.88.0.0/14",
		"46.4.0.0/16",
		"78.46.0.0/15",
		"85.10.192.0/18",
		"88.198.0.0/16",
		"88.99.0.0/16",
		"91.107.128.0/17",
		"116.202.0.0/15",
		"116.203.0.0/16",
		"128.140.0.0/17",
		"135.181.0.0/16",
		"136.243.0.0/16",
		"138.201.0.0/16",
		"142.132.128.0/17",
		"144.76.0.0/16",
		"148.251.0.0/16",
		"157.90.0.0/16",
		"159.69.0.0/16",
		"162.55.0.0/16",
		"167.233.0.0/16",
		"168.119.0.0/16",
		"178.63.0.0/16",
		"188.40.0.0/16",
		"195.201.0.0/16",
		"213.133.96.0/19",
		"213.239.192.0/18",
	}

	d.cidrs = make([]*net.IPNet, 0, len(ranges))
	for _, cidr := range ranges {
		_, ipNet, err := net.ParseCIDR(cidr)
		if err == nil {
			d.cidrs = append(d.cidrs, ipNet)
		}
	}
	d.loaded = true
}

// IsDatacenterIP checks if the given IP belongs to a known datacenter
func (d *DatacenterDetector) IsDatacenterIP(ipStr string) bool {
	d.mu.RLock()
	defer d.mu.RUnlock()

	ip := net.ParseIP(ipStr)
	if ip == nil {
		return false
	}

	for _, cidr := range d.cidrs {
		if cidr.Contains(ip) {
			return true
		}
	}

	return false
}

// Global instance
var defaultDetector *DatacenterDetector
var detectorOnce sync.Once

// IsDatacenterIP checks if IP belongs to a known datacenter (uses global instance)
func IsDatacenterIP(ip string) bool {
	detectorOnce.Do(func() {
		defaultDetector = NewDatacenterDetector()
	})
	return defaultDetector.IsDatacenterIP(ip)
}
